[{"title":"按需加载的一些方法","url":"/blog/2020/11/14/按需加载的几种方法/","content":"\n​\t当一个产品服务的客户足够多时，就一定有一些功能是只服务部分用户的。因此对不使用此功能的用户而言，加载这部分的代码并执行是完全不必要的事情。按需加载是一种很优雅的解决方案。\n\n​\t在此先不讨论图片等素材的按需加载，仅仅拿代码中的按需加载为例。\n\n## 按需加载\n\n​\t试想一个Loader类型，开发者可以自行生成一个示例。如果想要内置就生成一个实例以方便使用，如何实现更好呢？\n\n### 使用getter\n\n```js\n// 以下代码参考自[pixi.js](https://pixijs.download/dev/docs/PIXI.Loader.html)\nclass Loader {\n    constructor() {\n        \n    }\n    static get shared() {\n        let shared = Loader._shared;\n        if (!shared) {\n            shared = new Loader();\n            Loader._shared = shared;\n        }\n        return shared;\n    }\n}\nLoader.shared  // Loader {}\n```\n\n这样可以实现在访问shared的初次，才生成对应的实例，后续访问直接返回该实例。\n\n### 使用Object.defineProperty\n\n在访问时会生成实例，但getter的访问效率不及键值对象。有没有办法在getter生成后直接把对应的键值赋值到此对象上呢？Object.defineProperty能很好地实现。\n\n```js\n/**\n * {obj} - 对象\n * {key} - 对象的键值\n * {initValue} - 生成键值的函数，返回值为作为键key对应的value\n */\nfunction lazy(obj, key, initValue) {\n    let getValue = function() {\n        let v = initValue.apply(this);\n        Object.defineProperty(obj, key, {\n            writable: true,\n        \tenumerable: true,\n            configurable: true,\n            value: v,\n        }); // 把value直接更新，取消掉get\n        getValue = null;\n        return v;\n    }\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: getValue,\n        set(v) {\n            throw new Error('lazy value cannot be assigned');\n        }\n    })\n};\nclass Loader {\n    constructor() {\n        \n    }\n}\nlazy(Loader, 'shared', () => new Loader());\nLoader.shared // Loader {}\n```\n\n\n\n### 重定义\n\nObject.defineProperty就是一种对值的重定义。对值进行重定义这种思想有没有可能在其他方面应用呢？\n\n比如说当一个函数执行返回的结果是异步的时候，有没有可能直接将这个函数给按需加载。\n\n可不可以先把这个函数抽象成一个delay函数，第一次的调用都会让其开始加载这个文件，在没有加载成功前的调用都会按顺序记录调用参数。在加载成功后再执行之前保存的调用参数，并在后续调用时直接执行加载成功后的函数。\n\n当然，此函数也不能有其返回值。因为未加载前不能确定函数是否存在返回值。\n\n示例如下。\n\n```js\n// hello.js\nwindow.getValueAsync = function(arg, cb) {\n    cb('hello');\n}\n// index.js\nconst getValueAsync = delay((resolve) => {\n    loadScript('./hello.js').then(() => {\n        resolve(window.getValueAsync);\n        delete window.getValueAsync\n    });\n});\ngetValueAsync('xxx', (value) => {\n    console.log(value);\n})\ngetValueAsync('xxx2', (value) => {\n    console.log(value);\n})\nfunction delay(wrapperFunc) {\n    let delayed = [];\n    let isResolved = false;\n    let resolvedFunc = null;\n    function resolve(resultFunc) { // 加载成功\n        if (typeof resultFunc !== 'function') throw new Error('resolve function please');\n        if (isResolved) return;\n        delayed.forEach(([_this, args]) => {\n          resultFunc.apply(_this, args);\n        });\n        delayed = null;\n        resolvedFunc = resultFunc;\n        isResolved = true;\n    }\n    return function delayedFunc() { \n        //在没有resolve时存储参数\n        // resolve之后做一个转发，保证可以通过同一个之前的变量调用如 getValueAsync\n        if (isResolved) return resolvedFunc.apply(this, arguments);\n        // 还没调用过就开始初始化\n        if (delayed.length === 0) wrapperFunc(resolve);\n        delayed.push([this, arguments]);\n        return 'delaying';\n    }\n}\n// 也可以把异步callback来改为promise\n```\n\n因此为了按需加载，也可以把先加载再同步执行的代码改写为异步执行，在执行时才加载的方案。\n\n## 粒度的控制\n\n​\t按需加载就注定需要把加载的各个部分分离成不同的文件，bundleless工具在开发模式下就是最细粒度的按需加载。但在用户使用过程中，受限于网速，不能以最细粒度完成按需加载。\n\n​\t可以将较细粒度的文件分别打包。打包的大小可以自己设置一个定值最大值(如500KB)。\n\n## 总结\n\n​\t在访问某些网页游戏时，总需要过多的文件加载才能正式进入游戏。因此有一个颇为玩具性质的想法，在使用的时候才开始加载。比如下面拿pixi.js举例：\n\n```js\ngetSprite('ui/atk.png');\n// 在没有加载时 先返回一个Loading Sprite, 加载成功后再去更新Loading Sprite。\n// 以此来将异步的调用再次转换为同步的使用方法。\n```\n\n​\t如果在最底层的实现都是按需加载，能否在顶层实现一个按需加载的应用呢？\n\n​\t当然加载动画也是需要的，每点击一个功能都要进行加载的话自然也很不方便，有没有什么方便进行预加载的手段呢？\n\n","tags":["lazy loading"]},{"title":"bundleless开发的一些思考","url":"/blog/2020/11/12/bundleless开发的一些思考/","content":"\n在开发过程中，我们使用最新的语言特性，及支持最新特性的浏览器，同时，也使用`sourcemap` `hot reloading`,` hot replacement` 来提高开发效率。但在build产物时，则会开启混淆压缩，编译到es5环境。\n\n​\t为什么会产生这种分歧呢？是因为服务对象的不同。在开发过程中，开发者倾向于提高开发效率和面向未来编程，而在使用过程中，用户需要稳定且兼容的服务，无论他使用的什么浏览设备，浏览器及任何版本都可以正常运行。因此开发中的编译处理是十分有必要的。\n\n​\t但大部分编译都是有副作用的，为了避免这些问题，应该满足以下因素\n\n1. 尽可能的无副作用\n> 在开启混淆压缩时，会对变量进行重命名，如果语句中有eval就可能会出现副作用。\n>\n> 在编译到es5环境中，某些特性没有完整的polyfill，也会带来副作用。\n>\n> 可以通过限制语法，来实现副作用的减少。\n\n2. 完备的测试\n> 自动测试。\n>\n> 各个环境的测试。(有没有可能实现自动测试多个环境的工具？)\n\n​\t而bundless也可以是开发中的一环。在开发过程中由于资源加载速度没有限制，我们完全可以不进行打包，而选择加载分离的js文件，在对应js变化时也可只编译对应js文件。\n\n### 简单实现\n\n#### 独立编译\n\n每一个文件都要进行对应的处理，比如不同的模块配置。\n\n 1. 使用esm模块，浏览器支持此模块\n\n 2. cjs模块，编译到esm模块\n\n    cjs在限制部分语法的情况下，可以编译到esm模块\n\n    ```js\n    // hello.js\n    module.exports = function hello() {\n        console.log('hello');\n    } //====> export default function hello()\n    // world.js\n    module.exports = function hello() {\n        console.log('world');\n    } //====> export default function hello()\n    // index.js\n    const hello2 = () => {\n        require('./hello.js')();\n        require('./world.js')();\n    }\n    module.exports = hello2;\n    // ===> 比如检测 require('xxx')的正则表达式，限制参数只能是字符串\n    import hash1 from './hello.js';\n    import hash2 from './world.js';\n    const hello2 = () => {\n        hash1();\n        hash2();\n    }\n    module.exports = hello2;\n    ```\n\n    当然也可以自己不使用esm格式，像amd类似的格式也可以\n\n    ```js\n    wrapper('./hello.js', './world.js', function() {\n        const hello2 = () => {\n            require('./hello.js')();\n            require('./world.js')();\n        }\n        module.exports = hello2;\n    });\n    // 全局变量wrapper， 在加载完子依赖后再执行后续内容\n    // 全局变量require， 加载文件，如果已经加载则返回缓存\n    // module.exports 表明此模块最终加载结果。\n    ```\n\n#### 按需编译\n\n* node_modules里的依赖  \n>   如果有esm格式可直接使用，如果没有可以编译到esm格式，并生成对应版本的缓存。只有在更新版本时才会重新生成缓存。(之前使用snowpack过程中，更新了软件包但还是使用旧版本的缓存，需用snowpack --reload清空，较为不方便)\n\n* 导入js文件  \n>1. 启动express服务, 最开始所有js文件都标记为dirty。\n>2. 在访问到标记dirty的js文件时，对js文件进行编译，返回编译后的文件，清除dirty标记。\n>3. 在访问没有dirty标记的文件时，直接返回上次编译文件。\n>4. 通过watchFile(比如[chokidar](https://github.com/paulmillr/chokidar))监测js文件的更改，在更改后将此文件标记为dirty，刷新页面。\n  \n\n#### hot replacement 热重载\n\n​\t文件改变时，触发该文件刷新\n\n​\t该文件的父依赖接受到子依赖刷新事件\n\n​\t因此父依赖代码中应包含对应的处理代码，如果处理不了则触发父依赖进一步刷新。\t\n\n## 总结\n\n​\tbundleless是未来。目前受限的一个原因是因为部分现有的软件包并没有esm格式。\n\n​\tbundleless的思想也可应用到别的方面，比如在游戏开发中，直接导入分离的图片素材，而在发布时可以将图片自动打包成一张或多张图片，也可按需加载，在使用到某个素材时才加载对应的打包好的图片。不过需要增加一个处理层，确保分离导入和打包导入都能获得一致的返回结果。\n\n​\t在这种开发模式中，测试驱动型开发(BDD)可以大展身手。因为有完备的测试逻辑，能在不合理地使用了被限制的语法时得到测试失败提示，从而可以更\"冒进\"地进行工程开发，在追求开发效率的路上狂奔。","tags":["bundleless","snowpack"]},{"title":"遇见前端","url":"/blog/2020/10/22/与前端之缘/","content":"\n​\t本人就读于电子信息科学与技术专业。这专业是一言难尽，既学信息通信专业的课程(如通信原理)，又学部分计算机课程(比如数据结构与算法)，还有很多电子的课程(模电、数电、8086汇编、VHDL、嵌入式、焊板子实验)。\n\n----待更新\n\n"}]